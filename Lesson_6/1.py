"""
1. Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков. Проанализировать
результат и определить программы с наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи. Результаты анализа вставьте в виде
комментариев к коду. Также укажите в комментариях версию Python
и разрядность вашей ОС.
"""

# Python 3.7.2 WIN 64

from memory_profiler import profile
import random


@profile
def without_sieve(n):
    lst = []
    for i in range(2, n+1):
        for j in range(2, i):
            if i % j == 0:
                # если делитель найден, число не простое.
                break
        else:
            lst.append(i)
    return lst

@profile
def sieve(n):
    a = list(range(n + 1))
    a[1] = 0
    lst_new = []
    i = 2
    while i <= n:
        if a[i] != 0:
            lst_new.append(a[i])
            for j in range(i, n+1, i):
                a[j] = 0
        i += 1
    return lst_new


if __name__ == "__main__":

    print(10)
    without_sieve(10)
    sieve(10)
    print(100)
    without_sieve(100)
    sieve(100)
    print(1000)
    without_sieve(1000)
    sieve(1000)
    print(10000)
    without_sieve(10000)
    sieve(10000)


"""
При (m = 10)
Алгоритм без решета задействует  - 14.0 MiB;
Алгоритм решето Эратосфена задействует  - 14.1 MiB;

При (m = 100)
Алгоритм без решета задействует  - 14.1 MiB;
Алгоритм решето Эратосфена задействует  - 14.1 MiB;

При (m = 1000)
Алгоритм без решета задействует  - 14.1 MiB;
Алгоритм решето Эратосфена задействует  - 14.1 MiB;

При (m = 10000)
Алгоритм без решета задействует  - 14.1 MiB;
Алгоритм решето Эратосфена задействует  - 14.4 MiB (+ 0.3 MiB);

Можно сделать вывод, что алгоритмы с точки зрения
использования памяти работают с похожей эфективностью. Решето Эратосфена
использует чуть больше памяти ввиду использования дополнительного массива a[].
Однако, если учесть совокупность показателей (время + память), то решето также
остается более эффектиным алгоритмом."""
